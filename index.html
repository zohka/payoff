<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <!-- Viewport設定: 自動ズームを防ぐために maximum-scale=1.0, user-scalable=no を追加 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Payoff - Project Manager</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (for JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts (Noto Sans JP) -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #020617; /* slate-950 */
            /* iOSでのタップハイライトを無効化 */
            -webkit-tap-highlight-color: transparent;
        }
        /* Custom Utilities */
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
        
        /* Modal Animation */
        @keyframes modalFadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .animate-modal { animation: modalFadeIn 0.2s ease-out forwards; }

        /* モバイル端末での入力時ズーム防止策 
           画面幅が狭い場合、入力要素のフォントサイズを強制的に16pxにする
        */
        @media screen and (max-width: 768px) {
            input, textarea, select {
                font-size: 16px !important;
            }
        }
    </style>
</head>
<body class="text-slate-200 overflow-hidden">
    <div id="root" class="h-screen w-full"></div>

    <script type="text/babel">
        const { useState, useMemo, useEffect, useCallback, useRef } = React;

        // --- Icon Components ---
        const IconBase = ({ children, className = "", ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>
        );

        const Plus = (p) => <IconBase {...p}><path d="M5 12h14"/><path d="M12 5v14"/></IconBase>;
        const Trash2 = (p) => <IconBase {...p}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></IconBase>;
        const Edit2 = (p) => <IconBase {...p}><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></IconBase>;
        const AlertCircle = (p) => <IconBase {...p}><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></IconBase>;
        const BookOpen = (p) => <IconBase {...p}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></IconBase>;
        const Zap = (p) => <IconBase {...p}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></IconBase>;
        const Activity = (p) => <IconBase {...p}><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></IconBase>;
        const Info = (p) => <IconBase {...p}><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></IconBase>;
        const LayoutDashboard = (p) => <IconBase {...p}><rect width="7" height="9" x="3" y="3" rx="1"/><rect width="7" height="5" x="14" y="3" rx="1"/><rect width="7" height="9" x="14" y="12" rx="1"/><rect width="7" height="5" x="3" y="16" rx="1"/></IconBase>;
        const Layers = (p) => <IconBase {...p}><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></IconBase>;
        const PenTool = (p) => <IconBase {...p}><path d="m12 19 7-7 3 3-7 7-3-3z"/><path d="m18 13-1.5-7.5L2 2l3.5 14.5L13 18l5-7z"/><path d="m2 2 7.586 7.586"/><circle cx="11" cy="11" r="2"/></IconBase>;
        const ArrowLeft = (p) => <IconBase {...p}><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></IconBase>;
        const X = (p) => <IconBase {...p}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></IconBase>;
        const LinkIcon = (p) => <IconBase {...p}><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></IconBase>;
        const LogIn = (p) => <IconBase {...p}><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/><polyline points="10 17 15 12 10 7"/><line x1="15" x2="3" y1="12" y2="12"/></IconBase>;
        const StickyNote = (p) => <IconBase {...p}><path d="M15.5 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3Z"/><path d="M15 3v6h6"/></IconBase>;
        const Folder = (p) => <IconBase {...p}><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"/></IconBase>;
        const Check = (p) => <IconBase {...p}><polyline points="20 6 9 17 4 12"/></IconBase>;
        const MoreVertical = (p) => <IconBase {...p}><circle cx="12" cy="12" r="1"/><circle cx="12" cy="5" r="1"/><circle cx="12" cy="19" r="1"/></IconBase>;
        const Download = (p) => <IconBase {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></IconBase>;
        const Upload = (p) => <IconBase {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></IconBase>;

        // --- Constants & Types ---
        const MAX_TOKEN_VALUE = 100;
        const DEFAULT_PROJECT_ID = 'p1';
        
        const DEFAULT_DATA = {
            id: DEFAULT_PROJECT_ID,
            name: 'サンプル：復讐の物語',
            lastModified: Date.now(),
            tokens: [
                { id: 't1', name: '魔王討伐', type: 'main', initialValue: 100, description: '平和を取り戻すための戦い' },
                { id: 't2', name: '父の復讐', type: 'sub', initialValue: 60, description: '父を殺した騎士を探す' },
                { id: 't3', name: '謎の指輪', type: 'sub', initialValue: 40, description: '森で拾った指輪の持ち主を探す' }
            ],
            scenes: [
                { 
                    id: 's1', 
                    title: '旅立ち', 
                    summary: '故郷の村を出る。父の形見の剣を手に取る。', 
                    consumptions: { 't1': 10, 't2': 20 },
                    issuedTokenIds: [],
                    note: '復讐の誓いを立てることでトークンt2がアクティブ化'
                },
                { 
                    id: 's2', 
                    title: '迷いの森', 
                    summary: '森で奇妙な光る指輪を拾う。', 
                    consumptions: { 't1': 5, 't2': 0 }, 
                    issuedTokenIds: ['t3'],
                    note: '新しいトークン獲得'
                }
            ],
            memo: ''
        };

        // --- Components ---

        const Card = ({ children, className = "", onClick }) => (
          <div 
            onClick={onClick}
            className={`bg-slate-900 rounded-xl border border-slate-800 shadow-xl overflow-hidden ${className}`}
          >
            {children}
          </div>
        );

        const Button = ({ children, onClick, variant = "primary", className = "", disabled = false, size = "md" }) => {
          const sizeStyles = {
            sm: "px-3 py-1.5 text-xs",
            md: "px-4 py-2 text-sm",
            lg: "px-6 py-3 text-base"
          };
          
          const variants = {
            primary: "bg-indigo-600 hover:bg-indigo-500 text-white shadow-lg shadow-indigo-900/50 border border-indigo-500",
            secondary: "bg-slate-800 hover:bg-slate-700 text-slate-300 border border-slate-700",
            danger: "bg-red-500/10 text-red-400 hover:bg-red-500/20 border border-red-500/20",
            ghost: "bg-transparent hover:bg-slate-800 text-slate-400 hover:text-slate-200"
          };
          
          return (
            <button 
              onClick={onClick} 
              disabled={disabled}
              className={`${sizeStyles[size]} ${variants[variant]} ${className} rounded-lg font-medium transition-all duration-200 flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed active:scale-95`}
            >
              {children}
            </button>
          );
        };

        const Badge = ({ children, color = "indigo" }) => {
          const colors = {
            indigo: "bg-indigo-500/10 text-indigo-400 border-indigo-500/20",
            emerald: "bg-emerald-500/10 text-emerald-400 border-emerald-500/20",
            amber: "bg-amber-500/10 text-amber-400 border-amber-500/20",
            slate: "bg-slate-700/50 text-slate-400 border-slate-600"
          };
          return (
            <span className={`px-2 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider border ${colors[color] || colors.slate}`}>
              {children}
            </span>
          );
        };

        // --- Project Manager Hook & Logic ---

        function PayoffApp() {
          // --- State Management for Projects ---
          const [projects, setProjects] = useState(() => {
            try {
              const saved = localStorage.getItem('payoff_projects_v1');
              return saved ? JSON.parse(saved) : [DEFAULT_DATA];
            } catch (e) {
              console.error("Load failed", e);
              return [DEFAULT_DATA];
            }
          });

          const [activeProjectId, setActiveProjectId] = useState(() => {
            return localStorage.getItem('payoff_active_project_id') || DEFAULT_PROJECT_ID;
          });

          // Modal States
          const [isProjectModalOpen, setIsProjectModalOpen] = useState(false);
          const [editingProjectNameId, setEditingProjectNameId] = useState(null);
          const [tempProjectName, setTempProjectName] = useState("");
          
          // Project Menu State (Popover)
          const [projectMenu, setProjectMenu] = useState({ 
              isOpen: false, 
              id: null, 
              top: 0, 
              left: 0, 
              placement: 'bottom' // 'top' or 'bottom'
          });

          // Rename Modal State (Header)
          const [isRenameModalOpen, setIsRenameModalOpen] = useState(false);
          const [newNameInput, setNewNameInput] = useState("");

          // File Import Ref
          const fileInputRef = useRef(null);

          // Derive Active Project
          const activeProject = useMemo(() => {
            return projects.find(p => p.id === activeProjectId) || projects[0];
          }, [projects, activeProjectId]);

          // Persist Data
          useEffect(() => {
            localStorage.setItem('payoff_projects_v1', JSON.stringify(projects));
          }, [projects]);

          useEffect(() => {
            localStorage.setItem('payoff_active_project_id', activeProjectId);
          }, [activeProjectId]);

          // --- Adapter Functions for Single Project Logic ---
          const updateActiveProject = useCallback((updates) => {
            setProjects(prev => prev.map(p => 
              p.id === activeProjectId 
                ? { ...p, ...updates, lastModified: Date.now() } 
                : p
            ));
          }, [activeProjectId]);

          const tokens = activeProject.tokens;
          const scenes = activeProject.scenes;
          const memo = activeProject.memo;

          const setTokens = (newTokensOrFn) => {
             const newTokens = typeof newTokensOrFn === 'function' ? newTokensOrFn(tokens) : newTokensOrFn;
             updateActiveProject({ tokens: newTokens });
          };
          const setScenes = (newScenesOrFn) => {
             const newScenes = typeof newScenesOrFn === 'function' ? newScenesOrFn(scenes) : newScenesOrFn;
             updateActiveProject({ scenes: newScenes });
          };
          const setMemo = (newMemo) => {
             updateActiveProject({ memo: newMemo });
          };

          // --- Project Management Actions ---

          const createProject = () => {
            const newId = `p${Date.now()}`;
            const newProject = {
              id: newId,
              name: '新規プロジェクト',
              lastModified: Date.now(),
              tokens: [],
              scenes: [],
              memo: ''
            };
            setProjects([...projects, newProject]);
            setActiveProjectId(newId);
            setIsProjectModalOpen(false);
          };

          const switchProject = (id) => {
            setActiveProjectId(id);
            setIsProjectModalOpen(false);
            setEditingScene(null);
            setEditingToken(null);
            setMobileSceneView('list');
          };

          const deleteProject = (id, e) => {
            e.stopPropagation();
            if (projects.length <= 1) {
              alert("最後のプロジェクトは削除できません。");
              return;
            }
            if (!confirm("プロジェクトを削除しますか？この操作は取り消せません。")) return;

            const newProjects = projects.filter(p => p.id !== id);
            setProjects(newProjects);
            if (activeProjectId === id) {
              setActiveProjectId(newProjects[0].id);
            }
            setProjectMenu({ ...projectMenu, isOpen: false });
          };

          const startRenameProject = (project, e) => {
            e.stopPropagation();
            setEditingProjectNameId(project.id);
            setTempProjectName(project.name);
            setProjectMenu({ ...projectMenu, isOpen: false });
          };

          const saveProjectName = (id) => {
             setProjects(prev => prev.map(p => p.id === id ? { ...p, name: tempProjectName } : p));
             setEditingProjectNameId(null);
          };

          // --- Menu Actions (Popover) ---
          const openProjectMenu = (id, e) => {
              e.stopPropagation();
              // Toggle if same ID is clicked
              if (projectMenu.isOpen && projectMenu.id === id) {
                  setProjectMenu({ ...projectMenu, isOpen: false });
                  return;
              }

              const rect = e.currentTarget.getBoundingClientRect();
              const menuHeight = 120; // 概算のメニュー高さ
              const windowHeight = window.innerHeight;
              
              // 画面下部にある場合は上に表示する判定
              const isBottom = rect.bottom + menuHeight > windowHeight;

              setProjectMenu({
                  isOpen: true,
                  id: id,
                  // ボタンの右端に合わせる
                  left: rect.right, 
                  // 上開きならボタンの上端、下開きならボタンの下端を基準にする
                  top: isBottom ? rect.top : rect.bottom,
                  placement: isBottom ? 'top' : 'bottom'
              });
          };

          const closeProjectMenu = () => {
              if (projectMenu.isOpen) {
                  setProjectMenu({ ...projectMenu, isOpen: false });
              }
          };

          // --- Rename Actions for Header ---
          const openHeaderRename = (e) => {
             e.stopPropagation();
             setNewNameInput(activeProject.name);
             setIsRenameModalOpen(true);
          };

          const saveHeaderRename = () => {
             if (!newNameInput.trim()) return;
             updateActiveProject({ name: newNameInput });
             setIsRenameModalOpen(false);
          };

          // --- Export & Import Actions ---
          const exportProject = (project, e) => {
            e.stopPropagation();
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(project, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", `payoff_${project.name.replace(/\s+/g, '_')}_${Date.now()}.json`);
            document.body.appendChild(downloadAnchorNode); // required for firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
            setProjectMenu({ ...projectMenu, isOpen: false });
          };

          const triggerImport = () => {
            if(fileInputRef.current) fileInputRef.current.click();
          };

          const handleImportFile = (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const parsed = JSON.parse(e.target.result);
                    // Simple Validation
                    if (!parsed || !Array.isArray(parsed.tokens) || !Array.isArray(parsed.scenes)) {
                        alert("無効なファイル形式です。Payoffのプロジェクトファイルを選択してください。");
                        return;
                    }

                    const newId = `p${Date.now()}`;
                    const newProject = {
                        ...parsed,
                        id: newId, // Always generate new ID to avoid conflict
                        name: `${parsed.name} (Imported)`,
                        lastModified: Date.now()
                    };

                    setProjects(prev => [...prev, newProject]);
                    alert(`プロジェクト「${newProject.name}」をインポートしました。`);
                } catch (err) {
                    console.error(err);
                    alert("ファイルの読み込みに失敗しました。");
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
          };

          // --- Existing UI State ---
          const [activeTab, setActiveTab] = useState('dashboard');
          const [editingToken, setEditingToken] = useState(null);
          const [editingScene, setEditingScene] = useState(null);
          const [mobileSceneView, setMobileSceneView] = useState('list');
          const [confirmModal, setConfirmModal] = useState({ isOpen: false, type: null, id: null, title: '' });

          // --- Computed State (Calculations) ---
          const tokenOrigins = useMemo(() => {
            const map = {}; 
            tokens.forEach(t => map[t.id] = null);
            scenes.forEach(s => {
              if (s.issuedTokenIds) {
                s.issuedTokenIds.forEach(tid => {
                  map[tid] = s.id;
                });
              }
            });
            return map;
          }, [tokens, scenes]);

          const tokenBalances = useMemo(() => {
            let currentBalances = {};
            const sceneIssuedTokens = new Set();
            scenes.forEach(s => (s.issuedTokenIds || []).forEach(tid => sceneIssuedTokens.add(tid)));

            tokens.forEach(t => {
              if (!sceneIssuedTokens.has(t.id)) {
                currentBalances[t.id] = t.initialValue;
              }
            });

            const history = scenes.map(scene => {
              if (scene.issuedTokenIds) {
                scene.issuedTokenIds.forEach(tid => {
                  const token = tokens.find(t => t.id === tid);
                  if (token) {
                    currentBalances[tid] = token.initialValue;
                  }
                });
              }

              Object.keys(scene.consumptions || {}).forEach(tokenId => {
                if (currentBalances[tokenId] !== undefined) {
                  currentBalances[tokenId] = Math.max(0, currentBalances[tokenId] - (scene.consumptions[tokenId] || 0));
                }
              });

              return { 
                sceneId: scene.id, 
                sceneTitle: scene.title, 
                balances: { ...currentBalances }, 
                activeTokens: Object.keys(currentBalances),
                issuedHere: scene.issuedTokenIds || [],
                consumptions: scene.consumptions
              };
            });

            return { history, finalBalances: currentBalances };
          }, [tokens, scenes]);

          const diagnostics = useMemo(() => {
            const issues = [];
            Object.keys(tokenBalances.finalBalances).forEach(tid => {
              const token = tokens.find(t => t.id === tid);
              if (token && token.initialValue === tokenBalances.finalBalances[tid]) {
                 issues.push({ type: 'warning', message: `トークン「${token.name}」は発行されましたが、まだ消費されていません。` });
              }
            });

            const issuedSet = new Set(Object.keys(tokenBalances.finalBalances));
            tokens.forEach(t => {
              if (!issuedSet.has(t.id)) {
                 issues.push({ type: 'info', message: `トークン「${t.name}」はまだ物語に登場（発行）していません。` });
              }
            });

            if (scenes.length > 0) {
              const lastScene = scenes[scenes.length - 1];
              const totalConsumed = Object.values(lastScene.consumptions || {}).reduce((a, b) => a + b, 0);
              if (totalConsumed === 0 && (lastScene.issuedTokenIds || []).length === 0) {
                issues.push({ type: 'danger', message: `最新シーンでトークンの消費も発行も行われていません（停滞）。` });
              }
            }

            const allZero = Object.values(tokenBalances.finalBalances).every(v => v === 0) && tokens.length > 0;
            if (allZero && scenes.length > 0) {
              issues.push({ type: 'info', message: "全てのトークンが完済されました。" });
            }
            return issues;
          }, [tokenBalances, tokens, scenes]);


          // --- Handlers (Existing) ---
          const addToken = () => {
            const newToken = { id: `t${Date.now()}`, name: '新規トークン', type: 'sub', initialValue: 50, description: '' };
            setTokens([...tokens, newToken]);
            setEditingToken(newToken.id);
          };
          const updateToken = (id, updates) => setTokens(tokens.map(t => t.id === id ? { ...t, ...updates } : t));
          
          const initiateDeleteToken = (id, name) => setConfirmModal({ isOpen: true, type: 'token', id: id, title: name || 'トークン' });
          const initiateDeleteScene = (id, title) => setConfirmModal({ isOpen: true, type: 'scene', id: id, title: title || 'シーン' });
          
          const executeDelete = () => {
            if (confirmModal.type === 'token') {
              setTokens(tokens.filter(t => t.id !== confirmModal.id));
              if (editingToken === confirmModal.id) setEditingToken(null);
            } else if (confirmModal.type === 'scene') {
              setScenes(scenes.filter(s => s.id !== confirmModal.id));
              if (editingScene === confirmModal.id) handleBackToList();
            }
            setConfirmModal({ isOpen: false, type: null, id: null, title: '' });
          };
          const closeModal = () => setConfirmModal({ isOpen: false, type: null, id: null, title: '' });

          const addScene = () => {
            const newScene = { id: `s${Date.now()}`, title: '新規シーン', summary: '', consumptions: {}, issuedTokenIds: [], note: '' };
            setScenes([...scenes, newScene]);
            setEditingScene(newScene.id);
            setMobileSceneView('detail'); 
          };
          const updateScene = (id, updates) => setScenes(scenes.map(s => s.id === id ? { ...s, ...updates } : s));
          const updateConsumption = (sceneId, tokenId, value) => {
            const scene = scenes.find(s => s.id === sceneId);
            if (!scene) return;
            const newConsumptions = { ...scene.consumptions, [tokenId]: parseInt(value) };
            updateScene(sceneId, { consumptions: newConsumptions });
          };
          const toggleIssuedToken = (sceneId, tokenId) => {
            const scene = scenes.find(s => s.id === sceneId);
            if (!scene) return;
            let newIssued = [...(scene.issuedTokenIds || [])];
            if (newIssued.includes(tokenId)) {
              newIssued = newIssued.filter(id => id !== tokenId);
            } else {
              const updatedScenes = scenes.map(s => {
                if (s.id === sceneId) return s; 
                if (s.issuedTokenIds && s.issuedTokenIds.includes(tokenId)) return { ...s, issuedTokenIds: s.issuedTokenIds.filter(id => id !== tokenId) };
                return s;
              });
              setScenes(updatedScenes.map(s => s.id === sceneId ? { ...s, issuedTokenIds: [...newIssued, tokenId] } : s));
              return;
            }
            updateScene(sceneId, { issuedTokenIds: newIssued });
          };
          const handleSceneSelect = (sceneId) => { setEditingScene(sceneId); setMobileSceneView('detail'); };
          const handleBackToList = () => { setMobileSceneView('list'); setEditingScene(null); };


          // --- Renderers ---
          
          const renderRenameModal = () => (
            <div className="fixed inset-0 z-[80] flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-fade-in" onClick={() => setIsRenameModalOpen(false)}>
              <div className="bg-slate-900 border border-slate-700 rounded-xl shadow-2xl w-full max-w-sm overflow-hidden animate-modal" onClick={e => e.stopPropagation()}>
                 <div className="p-6">
                    <h3 className="text-lg font-bold text-slate-100 mb-4 flex items-center gap-2">
                        <Edit2 className="w-5 h-5 text-indigo-400" /> プロジェクト名の変更
                    </h3>
                    <input 
                        type="text" 
                        value={newNameInput} 
                        onChange={(e) => setNewNameInput(e.target.value)}
                        className="w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg text-slate-100 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
                        autoFocus
                        placeholder="プロジェクト名を入力"
                        onKeyDown={(e) => e.key === 'Enter' && saveHeaderRename()}
                    />
                 </div>
                 <div className="bg-slate-800/50 p-4 flex gap-3 justify-end border-t border-slate-800">
                    <Button variant="ghost" onClick={() => setIsRenameModalOpen(false)}>キャンセル</Button>
                    <Button variant="primary" onClick={saveHeaderRename}>保存</Button>
                 </div>
              </div>
            </div>
          );

          const renderProjectModal = () => (
             <div className="fixed inset-0 z-[60] flex items-center justify-center p-4 bg-black/80 backdrop-blur-sm animate-fade-in" onClick={() => setIsProjectModalOpen(false)}>
                <div className="bg-slate-900 border border-slate-700 rounded-xl shadow-2xl w-full max-w-lg overflow-hidden animate-modal flex flex-col max-h-[80vh]" onClick={closeProjectMenu}>
                    <div className="p-4 border-b border-slate-800 flex justify-between items-center bg-slate-950/50">
                        <h3 className="font-bold text-lg text-slate-100 flex items-center gap-2">
                            <Folder className="w-5 h-5 text-indigo-400" /> Projects
                        </h3>
                        <div className="flex gap-2">
                            <input 
                                type="file" 
                                ref={fileInputRef} 
                                style={{ display: 'none' }} 
                                accept=".json,.txt" 
                                onChange={handleImportFile} 
                            />
                            <Button size="sm" onClick={triggerImport} variant="secondary" className="border-dashed"><Upload className="w-4 h-4" /> Import</Button>
                            <Button size="sm" onClick={createProject} variant="primary"><Plus className="w-4 h-4" /> New</Button>
                            <button onClick={() => setIsProjectModalOpen(false)} className="p-2 hover:bg-slate-800 rounded-lg text-slate-400"><X className="w-5 h-5" /></button>
                        </div>
                    </div>
                    {/* onScrollでメニューを閉じることで、スクロール時にメニューが置いていかれるのを防ぐ */}
                    <div className="p-4 overflow-y-auto custom-scrollbar space-y-3" onScroll={closeProjectMenu}>
                        {projects.map(p => (
                            <div key={p.id} className={`group relative rounded-lg border transition-all ${activeProjectId === p.id ? 'bg-indigo-900/20 border-indigo-500/50' : 'bg-slate-800/50 border-slate-700 hover:border-slate-600'}`}>
                                <div className="p-4 cursor-pointer" onClick={() => switchProject(p.id)}>
                                    <div className="flex justify-between items-start mb-2">
                                        {editingProjectNameId === p.id ? (
                                            <div className="flex gap-2 w-full mr-8" onClick={e => e.stopPropagation()}>
                                                <input 
                                                    type="text" 
                                                    value={tempProjectName} 
                                                    onChange={e => setTempProjectName(e.target.value)}
                                                    // Mobile Zoom Prevent: text-base for mobile, text-sm for desktop
                                                    className="w-full bg-slate-950 border border-indigo-500 rounded px-2 py-1 text-base md:text-sm focus:outline-none"
                                                    autoFocus
                                                />
                                                <button onClick={() => saveProjectName(p.id)} className="p-1 bg-indigo-600 rounded text-white"><Check className="w-4 h-4" /></button>
                                            </div>
                                        ) : (
                                            <h4 className={`font-bold ${activeProjectId === p.id ? 'text-indigo-200' : 'text-slate-200'}`}>{p.name}</h4>
                                        )}
                                    </div>
                                    <div className="text-xs text-slate-500 flex gap-3">
                                        <span><Layers className="w-3 h-3 inline mr-1" /> {p.tokens.length} Tokens</span>
                                        <span><PenTool className="w-3 h-3 inline mr-1" /> {p.scenes.length} Scenes</span>
                                        <span className="ml-auto">Last: {new Date(p.lastModified).toLocaleDateString()}</span>
                                    </div>
                                </div>
                                
                                {/* Active Indicator */}
                                {activeProjectId === p.id && (
                                    <div className="absolute top-4 right-10 text-indigo-400">
                                        <div className="w-2 h-2 bg-indigo-500 rounded-full shadow-[0_0_10px_rgba(99,102,241,0.5)]"></div>
                                    </div>
                                )}

                                {/* Menu Trigger */}
                                <div className="absolute top-2 right-2">
                                    <button 
                                        onClick={(e) => openProjectMenu(p.id, e)}
                                        className="p-1.5 hover:bg-slate-700 rounded text-slate-400"
                                    >
                                        <MoreVertical className="w-4 h-4" />
                                    </button>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
                
                {/* Project Menu (Portal-like Popover) 
                  リストの外側に描画することで overflow:hidden の影響を受けずに表示する。
                  position: fixed で画面上の絶対位置に表示。
                */}
                {projectMenu.isOpen && (() => {
                    // 対象のプロジェクトデータを取得
                    const p = projects.find(proj => proj.id === projectMenu.id);
                    if (!p) return null;

                    // メニューのスタイル計算
                    const style = {
                        position: 'fixed',
                        left: `${projectMenu.left}px`,
                        transform: 'translateX(-100%)', // 右端合わせ
                        zIndex: 100,
                        width: '9rem' // w-36
                    };

                    if (projectMenu.placement === 'top') {
                        style.bottom = `${window.innerHeight - projectMenu.top}px`;
                    } else {
                        style.top = `${projectMenu.top}px`;
                    }

                    return (
                        <div 
                            className="bg-slate-900 border border-slate-700 rounded-lg shadow-xl py-1 overflow-hidden animate-fade-in"
                            style={style}
                            onClick={(e) => e.stopPropagation()} // メニュー内クリックで閉じない
                        >
                            <button 
                                onClick={(e) => exportProject(p, e)}
                                className="w-full text-left px-3 py-2 text-xs text-slate-300 hover:bg-slate-800 flex items-center gap-2"
                            >
                                <Download className="w-3 h-3" /> Export
                            </button>
                            <button 
                                onClick={(e) => startRenameProject(p, e)}
                                className="w-full text-left px-3 py-2 text-xs text-slate-300 hover:bg-slate-800 flex items-center gap-2"
                            >
                                <Edit2 className="w-3 h-3" /> Rename
                            </button>
                            <button 
                                onClick={(e) => deleteProject(p.id, e)}
                                className="w-full text-left px-3 py-2 text-xs text-red-400 hover:bg-red-900/20 flex items-center gap-2 border-t border-slate-800"
                            >
                                <Trash2 className="w-3 h-3" /> Delete
                            </button>
                        </div>
                    );
                })()}
             </div>
          );

          const renderDashboard = () => (
            <div className="h-full overflow-y-auto overflow-x-hidden custom-scrollbar overscroll-contain pb-24">
              <div className="p-4 md:p-6 space-y-6 animate-fade-in max-w-7xl mx-auto">
                <div className="grid gap-4 md:gap-6 md:grid-cols-2">
                  <Card className="p-4 md:p-6 bg-gradient-to-br from-slate-900 to-slate-800">
                    <div className="flex items-center gap-3 mb-4 md:mb-6">
                      <div className="p-2 bg-indigo-500/20 rounded-lg text-indigo-400"><Activity className="w-5 h-5" /></div>
                      <h3 className="font-bold text-lg text-slate-100">Token Balance</h3>
                    </div>
                    <div className="space-y-4 md:space-y-5">
                      {tokens.map(t => {
                        const originSceneId = tokenOrigins[t.id];
                        const isIssued = originSceneId === null || Object.keys(tokenBalances.finalBalances).includes(t.id);
                        if (!isIssued) return null; 
                        const current = tokenBalances.finalBalances[t.id] ?? t.initialValue;
                        const percent = (current / t.initialValue) * 100;
                        return (
                          <div key={t.id} className="group">
                            <div className="flex justify-between text-sm mb-2">
                              <span className="font-medium text-slate-300 group-hover:text-indigo-400 transition-colors">{t.name}</span>
                              <span className="text-slate-500 font-mono text-xs">{current} / {t.initialValue}</span>
                            </div>
                            <div className="w-full bg-slate-800 rounded-full h-2 overflow-hidden border border-slate-700/50">
                              <div className={`h-full rounded-full transition-all duration-700 shadow-[0_0_10px_rgba(0,0,0,0.3)] ${t.type === 'main' ? 'bg-indigo-500 shadow-indigo-500/50' : 'bg-emerald-500 shadow-emerald-500/50'}`} style={{ width: `${percent}%` }}></div>
                            </div>
                          </div>
                        );
                      })}
                      {tokens.length === 0 && <p className="text-slate-500 text-sm">トークンが定義されていません。</p>}
                    </div>
                  </Card>
                  <Card className="p-4 md:p-6">
                      <div className="flex items-center gap-3 mb-4 md:mb-6">
                      <div className="p-2 bg-amber-500/20 rounded-lg text-amber-400"><Info className="w-5 h-5" /></div>
                      <h3 className="font-bold text-lg text-slate-100">Diagnostics</h3>
                    </div>
                    {diagnostics.length === 0 ? (
                      <div className="flex flex-col items-center justify-center h-24 md:h-40 text-slate-500 gap-2"><div className="w-2 h-2 bg-emerald-500 rounded-full animate-pulse" /><p className="text-sm">問題は検出されませんでした。</p></div>
                    ) : (
                      <ul className="space-y-2 md:space-y-3">
                        {diagnostics.map((d, i) => (
                          <li key={i} className={`text-xs md:text-sm p-3 rounded-lg flex gap-3 items-start border ${d.type === 'danger' ? 'bg-red-500/10 text-red-200 border-red-500/20' : d.type === 'warning' ? 'bg-amber-500/10 text-amber-200 border-amber-500/20' : 'bg-blue-500/10 text-blue-200 border-blue-500/20'}`}>
                            <AlertCircle className="w-4 h-4 mt-0.5 shrink-0 opacity-80" />{d.message}
                          </li>
                        ))}
                      </ul>
                    )}
                  </Card>
                </div>
                <Card className="p-4 md:p-6 overflow-hidden bg-slate-900 border-slate-800">
                  <h3 className="font-bold text-lg text-slate-100 mb-4 md:mb-6 flex items-center gap-2"><Zap className="w-4 h-4 text-yellow-500" /> Flow Chart</h3>
                  <div className="h-60 md:h-72 w-full overflow-x-auto pb-6 custom-scrollbar">
                    <div className="flex items-end gap-2 h-full min-w-max px-2">
                      <div className="flex flex-col items-center gap-2 w-12 md:w-16 group">
                        <div className="flex flex-col-reverse w-8 md:w-10 h-40 md:h-56 bg-slate-800/50 rounded-t-lg relative border-b border-white/5 transition-all group-hover:bg-slate-800">
                            {tokens.map((t) => {
                              if (tokenOrigins[t.id] !== null) return null;
                              const height = (t.initialValue / MAX_TOKEN_VALUE) * 100; 
                              return (<div key={t.id} className={`w-full transition-all border-t border-slate-900/20 ${t.type === 'main' ? 'bg-indigo-500/30' : 'bg-emerald-500/30'}`} style={{ height: `${height}%` }} title={`${t.name} (Initial)`} />);
                            })}
                        </div>
                        <span className="text-[10px] uppercase tracking-wider text-slate-500 font-mono">Start</span>
                      </div>
                      {tokenBalances.history.map((step, idx) => {
                        return (
                          <div key={step.sceneId} className="flex flex-col items-center gap-2 w-12 md:w-16 group">
                            <div className="flex flex-col-reverse w-8 md:w-10 h-40 md:h-56 rounded-t-lg overflow-hidden relative transition-all duration-300 bg-slate-800 border-b-2 border-transparent">
                                {tokens.map((t) => {
                                  const val = step.balances[t.id];
                                  if (val === undefined) return null;
                                  const height = (val / MAX_TOKEN_VALUE) * 100;
                                  return (
                                    <div key={t.id} className={`w-full transition-all duration-500 relative border-t border-slate-900/10 ${t.type === 'main' ? 'bg-indigo-600' : 'bg-emerald-500'}`} style={{ height: `${height}%` }} title={`${t.name}: ${val}`}>
                                       {step.issuedHere && step.issuedHere.includes(t.id) && (<div className="absolute inset-0 bg-white/40 animate-pulse z-10" title="New Token Issued!" />)}
                                    </div>
                                  );
                                })}
                            </div>
                            <div className="flex flex-col items-center relative">
                              <span className="text-xs font-bold font-mono text-slate-400">{idx + 1}</span>
                              {step.issuedHere && step.issuedHere.length > 0 && (<span className="absolute top-full w-max text-[8px] text-emerald-400 font-bold mt-0.5">+Token</span>)}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </Card>
              </div>
            </div>
          );

          const renderTokenEditor = () => (
            <div className="h-full overflow-y-auto overflow-x-hidden custom-scrollbar overscroll-contain pb-24">
              <div className="p-4 md:p-6 space-y-4 md:space-y-6 animate-fade-in max-w-7xl mx-auto">
                <div className="flex justify-between items-center bg-slate-900/50 p-4 rounded-xl border border-slate-800">
                  <div><h3 className="font-bold text-base md:text-lg text-slate-100">Token Vault</h3><p className="text-[10px] md:text-xs text-slate-500">物語の推進力を定義します</p></div>
                  <Button onClick={addToken} size="sm"><Plus className="w-4 h-4" /> <span className="hidden md:inline">Issue Token</span><span className="md:hidden">Add</span></Button>
                </div>
                <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
                  {tokens.map(token => {
                     const originId = tokenOrigins[token.id];
                     const originScene = originId ? scenes.find(s => s.id === originId) : null;
                     return (
                       <Card key={token.id} className={`transition-all duration-300 ${editingToken === token.id ? 'ring-2 ring-indigo-500 shadow-indigo-900/20' : ''}`}>
                         {editingToken === token.id ? (
                           <div className="p-4 space-y-4">
                             <div>
                               <label className="text-[10px] font-bold text-indigo-400 uppercase tracking-wider mb-1 block">Token Name</label>
                               <input type="text" value={token.name} onChange={(e) => updateToken(token.id, { name: e.target.value })} className="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded-md text-base md:text-sm text-slate-100 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500" placeholder="例: 復讐, 友情" autoFocus />
                             </div>
                             <div className="flex gap-3">
                               <div className="flex-1">
                                 <label className="text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-1 block">Type</label>
                                 <select value={token.type} onChange={(e) => updateToken(token.id, { type: e.target.value })} className="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded-md text-base md:text-sm text-slate-300 focus:border-indigo-500 focus:outline-none">
                                   <option value="main">Main</option><option value="sub">Sub</option>
                                 </select>
                               </div>
                               <div className="w-24">
                                 <label className="text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-1 block">Vol</label>
                                 <input type="number" value={token.initialValue} onChange={(e) => updateToken(token.id, { initialValue: parseInt(e.target.value) })} className="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded-md text-base md:text-sm text-slate-100 focus:border-indigo-500 focus:outline-none" />
                               </div>
                             </div>
                             <div>
                               <label className="text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-1 block">Definition</label>
                               <textarea value={token.description} onChange={(e) => updateToken(token.id, { description: e.target.value })} className="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded-md text-base md:text-sm text-slate-300 focus:border-indigo-500 focus:outline-none" rows={2} placeholder="関係性の定義..." />
                             </div>
                             <div className="flex justify-end gap-2 pt-2 border-t border-slate-800">
                               <Button variant="danger" size="sm" onClick={() => initiateDeleteToken(token.id, token.name)}><Trash2 className="w-3 h-3" /></Button>
                               <Button size="sm" onClick={() => setEditingToken(null)}>Save</Button>
                             </div>
                           </div>
                         ) : (
                           <div onClick={() => setEditingToken(token.id)} className="p-4 cursor-pointer group h-full flex flex-col relative">
                             <div className="absolute top-0 right-0 p-4 opacity-100 md:opacity-0 md:group-hover:opacity-100 transition-opacity"><Edit2 className="w-4 h-4 text-slate-400" /></div>
                             <div className="flex justify-between items-start mb-3">
                               <Badge color={token.type === 'main' ? 'indigo' : 'emerald'}>{token.type === 'main' ? 'MAIN' : 'SUB'}</Badge>
                               <span className="text-[10px] font-mono text-slate-500 border border-slate-800 px-1.5 py-0.5 rounded">ORIGIN: {originScene ? `SCENE ${scenes.findIndex(s=>s.id===originId)+1}` : 'INITIAL'}</span>
                             </div>
                             <h4 className="font-bold text-lg mb-2 text-slate-100">{token.name}</h4>
                             <div className="w-full bg-slate-800 h-1 rounded-full mb-3 overflow-hidden"><div className={`h-full ${token.type === 'main' ? 'bg-indigo-500' : 'bg-emerald-500'}`} style={{width: '100%'}}></div></div>
                             <p className="text-xs md:text-sm text-slate-400 leading-relaxed flex-1">{token.description || "未定義"}</p>
                           </div>
                         )}
                       </Card>
                     );
                  })}
                </div>
              </div>
            </div>
          );

          const renderSceneList = () => (
            <div className="flex-1 w-full md:w-80 flex flex-col gap-3 overflow-y-auto custom-scrollbar md:pr-2 px-4 md:px-0 py-4 pb-24 md:pb-0">
              <div className="flex justify-between items-center mb-2 px-1">
                  <h3 className="font-bold text-slate-400 text-sm uppercase tracking-wider">Timeline</h3>
                  <Button size="sm" onClick={addScene} variant="secondary"><Plus className="w-3 h-3" /> Add Scene</Button>
              </div>
              {scenes.map((scene, idx) => {
                const isStagnant = Object.values(scene.consumptions || {}).reduce((a,b)=>a+b, 0) === 0;
                const hasIssue = scene.issuedTokenIds && scene.issuedTokenIds.length > 0;
                return (
                  <div key={scene.id} onClick={() => handleSceneSelect(scene.id)} className={`p-4 rounded-xl border cursor-pointer transition-all active:scale-[0.98] ${editingScene === scene.id ? 'bg-indigo-900/20 border-indigo-500/50 shadow-lg shadow-indigo-900/20' : 'bg-slate-900 border-slate-800 hover:border-slate-600'}`}>
                    <div className="flex justify-between items-center mb-2">
                      <span className={`text-[10px] font-bold font-mono px-1.5 py-0.5 rounded ${editingScene === scene.id ? 'bg-indigo-500 text-white' : 'bg-slate-800 text-slate-500'}`}>#{idx + 1}</span>
                      <div className="flex gap-1">
                        {hasIssue && (<span className="text-[10px] text-emerald-400 flex items-center gap-1 bg-emerald-900/20 px-1.5 py-0.5 rounded border border-emerald-900/50"><LogIn className="w-3 h-3" /> GET</span>)}
                        {isStagnant && !hasIssue && (<span className="text-[10px] text-amber-500 flex items-center gap-1 bg-amber-900/20 px-1.5 py-0.5 rounded border border-amber-900/50"><AlertCircle className="w-3 h-3" /> STAGNANT</span>)}
                      </div>
                    </div>
                    <h4 className={`font-bold text-sm mb-1 ${editingScene === scene.id ? 'text-indigo-200' : 'text-slate-200'}`}>{scene.title}</h4>
                    <p className="text-xs text-slate-500 truncate mb-2">{scene.summary || "概要なし"}</p>
                    <div className="flex flex-wrap gap-1">{Object.entries(scene.consumptions || {}).map(([tid, val]) => val > 0 && (<div key={tid} className="h-1.5 w-1.5 rounded-full bg-indigo-500" title={`-${val}`} />))}</div>
                  </div>
                );
              })}
            </div>
          );

          const renderSceneDetail = () => {
            if (!editingScene) return null;
            const scene = scenes.find(s => s.id === editingScene);
            if (!scene) return null;

            return (
              <div className="flex-1 w-full h-full bg-slate-900 md:rounded-xl border-t md:border border-slate-800 shadow-2xl flex flex-col z-20">
                <div className="p-4 md:p-6 border-b border-slate-800 bg-slate-900/95 backdrop-blur flex items-start gap-4 sticky top-0 z-10 flex-none">
                   <button onClick={handleBackToList} className="md:hidden mt-2 p-2 -ml-2 text-slate-400 hover:text-white"><ArrowLeft className="w-6 h-6" /></button>
                   <div className="flex-1">
                     <div className="flex justify-between items-start mb-2">
                       <div className="w-full mr-4">
                         <label className="text-[10px] font-bold text-slate-500 uppercase tracking-wider block mb-1">Scene Title</label>
                         <input type="text" value={scene.title} onChange={(e) => updateScene(editingScene, { title: e.target.value })} className="block w-full text-xl md:text-2xl font-bold bg-transparent border-b border-transparent hover:border-slate-700 focus:border-indigo-500 focus:outline-none transition-colors text-slate-100 placeholder-slate-700" placeholder="Untitled Scene" />
                       </div>
                       <Button variant="danger" onClick={() => initiateDeleteScene(editingScene, scene.title)} className="px-2 py-2"><Trash2 className="w-4 h-4" /></Button>
                     </div>
                     <textarea value={scene.summary} onChange={(e) => updateScene(editingScene, { summary: e.target.value })} className="w-full p-0 border-none bg-transparent text-base md:text-sm text-slate-400 focus:ring-0 resize-none placeholder-slate-700 leading-relaxed" rows={2} placeholder="ここに出来事の概要を入力..." />
                   </div>
                </div>

                <div className="flex-1 overflow-y-auto p-4 md:p-6 space-y-6 md:space-y-8 custom-scrollbar pb-24 md:pb-6">
                   <div className="bg-slate-800/30 p-4 md:p-5 rounded-xl border border-slate-800">
                     <div className="flex items-center gap-2 mb-4"><div className="p-1.5 bg-emerald-500/20 rounded text-emerald-500"><LinkIcon className="w-4 h-4" /></div><div><h4 className="font-bold text-sm text-slate-200">Token Acquisition</h4><p className="text-[10px] md:text-xs text-slate-500">このシーンで獲得・発生したトークン</p></div></div>
                     <div className="flex flex-wrap gap-2">
                       {tokens.map(token => {
                         const isIssuedHere = (scene.issuedTokenIds || []).includes(token.id);
                         const originId = tokenOrigins[token.id];
                         const isIssuedElsewhere = originId && originId !== scene.id;
                         if (isIssuedElsewhere) return null;
                         return (
                           <button key={token.id} onClick={() => toggleIssuedToken(scene.id, token.id)} className={`px-3 py-2 rounded-lg text-xs font-bold border transition-all flex items-center gap-2 ${isIssuedHere ? 'bg-emerald-500/20 border-emerald-500 text-emerald-400' : 'bg-slate-800 border-slate-700 text-slate-500 hover:border-slate-600'}`}>
                             <span className={`w-2 h-2 rounded-full ${token.type === 'main' ? 'bg-indigo-500' : 'bg-emerald-500'} ${!isIssuedHere && 'opacity-50'}`}></span>{token.name}{isIssuedHere && <LogIn className="w-3 h-3 ml-1" />}
                           </button>
                         );
                       })}
                     </div>
                     <p className="text-[10px] text-slate-600 mt-2 italic">* 初期トークン以外は、ここで選択することで初めて物語に登場（発行）します。</p>
                   </div>
                   <div className="bg-slate-800/30 p-4 md:p-5 rounded-xl border border-slate-800">
                     <div className="flex items-center gap-2 mb-6"><div className="p-1.5 bg-amber-500/20 rounded text-amber-500"><Zap className="w-4 h-4" /></div><div><h4 className="font-bold text-sm text-slate-200">Consumption</h4><p className="text-[10px] md:text-xs text-slate-500">関係性の変化量 (発行済のみ表示)</p></div></div>
                     <div className="space-y-6">
                       {tokens.map(token => {
                          const originId = tokenOrigins[token.id];
                          const isAvailable = originId === null || originId !== undefined;
                          if (!isAvailable) return null; 
                          const consumption = scene.consumptions[token.id] || 0;
                          return (
                            <div key={token.id} className="relative">
                              <div className="flex justify-between items-end mb-2"><div className="flex items-center gap-2"><span className={`w-2 h-2 rounded-full ${token.type === 'main' ? 'bg-indigo-500' : 'bg-emerald-500'}`}></span><span className="text-sm font-medium text-slate-300 truncate max-w-[150px]">{token.name}</span></div><span className={`font-mono text-sm font-bold ${consumption > 0 ? 'text-indigo-400' : 'text-slate-600'}`}>-{consumption}</span></div>
                              <input type="range" min="0" max="50" step="5" value={consumption} onChange={(e) => updateConsumption(editingScene, token.id, e.target.value)} className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-indigo-500 hover:accent-indigo-400" />
                            </div>
                          );
                       })}
                       {tokens.length === 0 && <p className="text-slate-500 text-xs italic">消費するトークンがありません。</p>}
                     </div>
                   </div>
                   <div>
                     <label className="text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-2 block flex items-center gap-2"><PenTool className="w-3 h-3" /> Memo</label>
                     <textarea value={scene.note} onChange={(e) => updateScene(editingScene, { note: e.target.value })} className="w-full p-4 border border-slate-700 rounded-xl text-base md:text-sm bg-slate-800 text-slate-300 focus:border-indigo-500 focus:outline-none transition-all placeholder-slate-600" rows={4} placeholder="チェックポイント: 関係性は不可逆的に変化しましたか？" />
                   </div>
                </div>
              </div>
            );
          };

          const renderSceneEditor = () => (
            <div className="w-full h-full max-w-7xl mx-auto flex flex-col md:flex-row md:gap-6 animate-fade-in md:py-8 md:px-6">
              <div className={`flex-1 flex flex-col h-full ${mobileSceneView === 'detail' ? 'hidden md:flex' : 'flex'}`}>{renderSceneList()}</div>
              <div className={`flex-[2] flex flex-col h-full ${mobileSceneView === 'list' ? 'hidden md:flex' : 'flex'}`}>{editingScene ? renderSceneDetail() : (
                  <div className="hidden md:flex h-full flex-col items-center justify-center text-slate-600 p-8 text-center bg-slate-900 rounded-xl border border-slate-800"><div className="w-16 h-16 bg-slate-800 rounded-full flex items-center justify-center mb-4 border border-slate-700"><BookOpen className="w-6 h-6 opacity-50" /></div><p className="text-sm">シーンを選択してください</p></div>
              )}</div>
            </div>
          );

          const renderMemoEditor = () => (
            <div className="h-full p-4 md:p-6 animate-fade-in max-w-7xl mx-auto flex flex-col">
              <div className="flex justify-between items-center mb-4"><h3 className="font-bold text-lg text-slate-100 flex items-center gap-2"><StickyNote className="w-5 h-5 text-indigo-400" /> Free Memo</h3><span className="text-xs text-slate-500 flex items-center gap-1">Auto-saved</span></div>
              <div className="flex-1 bg-slate-900 rounded-xl border border-slate-800 shadow-xl overflow-hidden p-1">
                <textarea value={memo} onChange={(e) => setMemo(e.target.value)} className="w-full h-full p-6 bg-transparent text-slate-300 placeholder-slate-600 focus:outline-none resize-none text-base leading-relaxed" placeholder="物語のアイデア、キャラクター設定、気になるセリフなどを自由に書き留めてください..." />
              </div>
            </div>
          );

          return (
            <div className="fixed inset-0 w-full h-full bg-slate-950 text-slate-200 font-sans selection:bg-indigo-500/30 selection:text-indigo-200 flex flex-col overflow-hidden overscroll-none">
              <style>{`
                .custom-scrollbar::-webkit-scrollbar { width: 4px; height: 4px; }
                .custom-scrollbar::-webkit-scrollbar-track { bg: transparent; }
                .custom-scrollbar::-webkit-scrollbar-thumb { background: #334155; border-radius: 2px; }
                @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
                .animate-fade-in { animation: fadeIn 0.3s ease-out forwards; }
              `}</style>

              {/* Modals */}
              {isProjectModalOpen && renderProjectModal()}
              {isRenameModalOpen && renderRenameModal()}
              {confirmModal.isOpen && (
                <div className="fixed inset-0 z-[70] flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-fade-in">
                  <div className="bg-slate-900 border border-slate-700 rounded-xl shadow-2xl w-full max-w-sm overflow-hidden animate-modal">
                     <div className="p-6">
                        <div className="flex justify-between items-start mb-4">
                          <div className="p-3 bg-red-500/10 rounded-full"><AlertCircle className="w-6 h-6 text-red-500" /></div>
                          <button onClick={closeModal} className="text-slate-500 hover:text-slate-300"><X className="w-5 h-5" /></button>
                        </div>
                        <h3 className="text-lg font-bold text-slate-100 mb-2">削除の確認</h3>
                        <p className="text-slate-400 text-sm leading-relaxed">「<span className="text-slate-200 font-medium">{confirmModal.title}</span>」を本当に削除しますか？<br/>この操作は取り消せません。</p>
                     </div>
                     <div className="bg-slate-800/50 p-4 flex gap-3 justify-end border-t border-slate-800">
                        <Button variant="ghost" onClick={closeModal}>キャンセル</Button>
                        <Button variant="danger" onClick={executeDelete}>削除する</Button>
                     </div>
                  </div>
                </div>
              )}

              {/* Header */}
              <header className="flex-none bg-slate-900/80 backdrop-blur-md border-b border-slate-800 z-30">
                <div className="max-w-7xl mx-auto px-4 md:px-6 h-14 md:h-16 flex items-center justify-between">
                  <div className="flex items-center gap-3 cursor-pointer group" onClick={() => setIsProjectModalOpen(true)}>
                    <div className="w-7 h-7 md:w-8 md:h-8 bg-gradient-to-br from-indigo-600 to-violet-600 rounded-lg flex items-center justify-center text-white font-bold shadow-lg shadow-indigo-900/50 text-sm md:text-base">P</div>
                    <div>
                        <h1 className="font-bold text-base md:text-lg tracking-tight text-slate-100 leading-none">Payoff</h1>
                        <div className="flex items-center gap-2">
                            <span className="text-[10px] text-slate-500 font-mono group-hover:text-indigo-400 transition-colors flex items-center gap-1">
                                {activeProject.name} <Folder className="w-3 h-3" />
                            </span>
                            {/* Rename Button in Header */}
                            <button 
                                onClick={openHeaderRename}
                                className="p-1 text-slate-600 hover:text-indigo-400 hover:bg-slate-800 rounded transition-colors"
                                title="名前を変更"
                            >
                                <Edit2 className="w-3 h-3" />
                            </button>
                        </div>
                    </div>
                  </div>
                  
                  <nav className="hidden md:flex bg-slate-800/50 p-1 rounded-lg border border-slate-700/50">
                    {[
                      { id: 'dashboard', icon: LayoutDashboard, label: 'Dashboard' },
                      { id: 'tokens', icon: Layers, label: 'Tokens' },
                      { id: 'scenes', icon: PenTool, label: 'Scenes' },
                      { id: 'memo', icon: StickyNote, label: 'Memo' }
                    ].map(tab => (
                      <button 
                        key={tab.id}
                        onClick={() => { setActiveTab(tab.id); if(tab.id === 'scenes') setMobileSceneView('list'); }} 
                        className={`px-4 py-1.5 rounded-md text-sm font-medium transition-all flex items-center gap-2 ${activeTab === tab.id ? 'bg-slate-700 text-indigo-400 shadow-sm' : 'text-slate-500 hover:text-slate-300 hover:bg-slate-800'}`}
                      >
                        <tab.icon className="w-4 h-4" />{tab.label}
                      </button>
                    ))}
                  </nav>
                </div>
              </header>

              {/* Main Content */}
              <main className="flex-1 overflow-hidden w-full relative">
                  {activeTab === 'dashboard' && renderDashboard()}
                  {activeTab === 'tokens' && renderTokenEditor()}
                  {activeTab === 'scenes' && renderSceneEditor()}
                  {activeTab === 'memo' && renderMemoEditor()}
              </main>

              {/* Mobile Bottom Nav */}
              <div className="flex-none md:hidden bg-slate-900 border-t border-slate-800 z-50 flex justify-around p-2 pb-safe">
                {[
                  { id: 'dashboard', icon: LayoutDashboard, label: 'Dash' },
                  { id: 'tokens', icon: Layers, label: 'Tokens' },
                  { id: 'scenes', icon: PenTool, label: 'Scenes' },
                  { id: 'memo', icon: StickyNote, label: 'Memo' }
                ].map(tab => (
                  <button 
                    key={tab.id}
                    onClick={() => { setActiveTab(tab.id); if(tab.id === 'scenes') setMobileSceneView('list'); }} 
                    className={`flex flex-col items-center justify-center w-full py-1 rounded-lg transition-all ${activeTab === tab.id ? 'text-indigo-400' : 'text-slate-500'}`}
                  >
                    <tab.icon className={`w-5 h-5 mb-1 ${activeTab === tab.id ? 'fill-indigo-500/20' : ''}`} />
                    <span className="text-[10px] font-medium">{tab.label}</span>
                  </button>
                ))}
              </div>
            </div>
          );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<PayoffApp />);
    </script>
</body>
</html>
